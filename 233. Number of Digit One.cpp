//每次考虑一个数位上面的1的个数。
//(n / m + 8) / 10 * m代表的是当前数位上的整周期1的个数，每一个周期m个1，周期数用n/m/10来算。
//当前数位是0的时候，显然不够一个周期，不算一个1。
//当前数位如果是1，那就要计算当前数位在n之前出现了多少次，一共n%m + 1次。
//当前数位如果是其他digit，则满足一个周期，用整周期的方法来算。为了在整周期中排除本数位是0/1的情况，选择+8的trick
class Solution {
public:
    int countDigitOne(int n)
    {
        int ones = 0;
        for (int64_t m = 1; m <= n; m *= 10)
            ones += (n / m + 8) / 10 * m + ((n / m) % 10 == 1) * (n % m + 1);
        return ones;
    }
};